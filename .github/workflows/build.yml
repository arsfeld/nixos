name: "Build"

on:
  push:
    branches: [main]
  workflow_dispatch:
  workflow_call:
    inputs:
      caller:
        required: false
        type: string
        description: "Name of the calling workflow (for logging)"
        default: "direct"
      host:
        required: false
        type: string
        description: "Single host to build for (if building just one machine)"
        default: ""
      platform:
        required: false
        type: string
        description: "Platform architecture for single host build"
        default: ""
      build_all:
        required: false
        type: boolean
        description: "Whether to build all machines in the matrix"
        default: true
    outputs:
      matrix:
        description: "Machine matrix for builds (when used as a matrix provider)"
        value: ${{ jobs.get-matrix.outputs.matrix }}
    secrets:
      TS_OAUTH_CLIENT_ID:
        required: false
      TS_OAUTH_SECRET:
        required: false
      ATTIC_TOKEN:
        required: false

jobs:
  # Job that provides the matrix definition
  get-matrix:
    runs-on: ubuntu-latest
    if: inputs.build_all == true
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Set Matrix
        id: set-matrix
        run: |
          cat << EOF >> $GITHUB_OUTPUT
          matrix={
            "machine": [
              {"host": "cloud", "platform": "aarch64-linux"},
              {"host": "raspi3", "platform": "aarch64-linux"},
              {"host": "storage", "platform": "x86-64-linux"}
            ]
          }
          EOF

  # Job that builds a single machine
  build-single:
    runs-on: ubuntu-latest
    if: inputs.host != '' && inputs.platform != '' && inputs.build_all == false
    timeout-minutes: 60
    permissions:
      contents: read
    steps:
    - name: Free up disk space
      run: |
        set -euo pipefail
        
        # Display initial disk space
        echo "Disk space before cleanup:"
        df -h
        
        # Remove unnecessary large packages
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /usr/local/lib/android
        sudo rm -rf /opt/ghc
        sudo rm -rf /opt/hostedtoolcache/CodeQL
        
        # Clean apt cache
        sudo apt clean
        sudo apt autoremove --yes
        
        # Remove Docker images
        docker image prune --all --force
        
        # Display disk space after cleanup
        echo "Disk space after cleanup:"
        df -h
    
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
    
    - name: Setup QEMU for aarch64
      if: inputs.platform == 'aarch64-linux'
      uses: docker/setup-qemu-action@v3
    
    - name: Setup Tailscale
      id: tailscale
      uses: tailscale/github-action@v2
      with:
        oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
        oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
        tags: tag:ci
        version: 1.82.0
      timeout-minutes: 2
    
    - name: Install Nix
      uses: DeterminateSystems/nix-installer-action@v9
      with:
        extra-conf: |
          fallback = true
          http-connections = 128
          max-substitution-jobs = 128
          extra-platforms = aarch64-linux i686-linux
    
    - name: Setup Nix cache
      uses: DeterminateSystems/magic-nix-cache-action@v3
    
    - name: Build system
      id: build_system
      uses: workflow/nix-shell-action@v3.3.0
      with:
        flakes-from-devshell: true
        script: |
          set -euo pipefail
          
          # Function to retry commands with timeout
          retry() {
            local max_attempts=3
            local attempt=1
            local delay=5
            local timeout=60
            
            until timeout $timeout "$@"; do
              if ((attempt == max_attempts)); then
                echo "Command '$*' failed after $max_attempts attempts"
                return 1
              fi
              
              echo "Command '$*' failed, attempt $attempt of $max_attempts. Retrying in ${delay}s..."
              sleep $delay
              ((attempt++))
            done
          }

          # Check if required secrets exist
          if [ -z "${{ secrets.ATTIC_TOKEN }}" ]; then
            echo "::error::ATTIC_TOKEN secret is not set"
            exit 1
          fi

          # Login to Attic and build
          retry attic login cloud https://fly-attic.fly.dev/system ${{ secrets.ATTIC_TOKEN }}
          retry attic use system
          
          # Wake up fly machine
          echo "Waking up Fly machine..."
          retry attic cache info system
          
          # Start Attic watch-store in background with proper process management
          attic_pid=""
          function cleanup {
            if [ -n "$attic_pid" ]; then
              echo "Cleaning up attic watch-store process ($attic_pid)"
              kill $attic_pid || true
            fi
          }
          trap cleanup EXIT
          
          echo "Starting Attic watch-store..."
          attic watch-store system &
          attic_pid=$!
          
          # Build the system
          echo "Building for ${{ inputs.host }}..."
          deploy --remote-build=false --skip-checks --targets ${{ inputs.host }} --boot
          
          # Ensure we know if the build succeeded
          echo "::notice::Build succeeded for ${{ inputs.host }}"

  # Job that builds all machines
  build-matrix:
    needs: get-matrix
    if: inputs.build_all == true
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.get-matrix.outputs.matrix) }}
    
    name: Build ${{ matrix.machine.host }}
    uses: ./.github/workflows/build.yml
    with:
      caller: ${{ inputs.caller }}
      host: ${{ matrix.machine.host }}
      platform: ${{ matrix.machine.platform }}
      build_all: false
    secrets:
      TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
      TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
      ATTIC_TOKEN: ${{ secrets.ATTIC_TOKEN }}